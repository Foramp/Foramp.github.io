---
layout:     post
title:      Java虚拟机内存理解
subtitle:   挖坑中
date:       2018-12-26
author:     Ze
header-img: img/post-bg-desk3.jpg
catalog: true
tags:
    - Java
    - Java虚拟机
---
# Java虚拟机区域理解

>断断续续看了好几天《Java虚拟机》，看的过程中总是会分不太清虚拟机各个区域的作用。
>
>所以打算认真梳理一下虚拟机内存区域的划分和使用。

## JVM的内存分配

![](https://zzbtuchuang.oss-cn-beijing.aliyuncs.com/2018-12-27_152534.jpg?Expires=1545899167&OSSAccessKeyId=TMP.AQHJux0-PN1t6NbWEg2GuGt5biSq4aDojQDlmFhEKScbn_GMMQbCvax6xlRNMC4CFQCGW9mFDXwsZLpZwSgNQtwV-eLnFAIVALFG3yUOMSCqYJfIzGXFB5JFvjKJ&Signature=ZafCNONFiapHulDRLzc192p54jY%3D)

#### 程序计数器

> 线程私有，空间小
>
> Java虚拟机规范中唯一一个没有规定任何OOMError情况的区域
>
> **执行Java方法时**，计数器记录的是正在执行的虚拟机字节码指令的地址；
>
> **执行Native方法时**，计数器值为（Undefined）

#### Java虚拟机栈

> 线程私有，生命周期和线程一致。
>
> 每个Java方法执行时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。
>
> 每个方法从调用至结束就是一个栈帧从入栈到出栈的过程。

> 局部变量表：存放编译期间就已经确定好（方法运行时所需分配的空间在栈帧中是完全确定的）的各种基本类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference）和返回地址类型（returnAddress）。其中只有long和double类型会占用两个局部变量空间(Slot)。

> OOM:虚拟机栈可动态扩展，而扩展时无法申请到足够的内存时
>
> SOF:线程请求的栈深度大于虚拟机所允许的深度时

#### 本地方法栈

> 与Java虚拟机栈基本相同，只是Java虚拟机栈是执行Java方法的，本地方法栈是执行Native方法的。

#### 方法区

> 线程共享
>
> 存储被虚拟机加载的类信息、常量、静态变量、JIT编译器编译后的代码等。
>
> 物理上可以不连续，垃圾回收比较少，所以也被称为永久区。但可以选择实现垃圾回收，该区域主要是针对常量池和类型的卸载

> OOM:当方法区无法满足内存分布时
>
> **[常量池](#constant_pool)**属于方法区的一部分，所以当常量池没有内存空间的时候就抛出OOMError异常

#### Java堆

> 线程共享，大多应用的JVM管理中最大的一块内存。
>
> 存放对象实例和数组。
>
> 物理上可以不连续但逻辑连续

> OOM:堆中没有内存完成实例分配，并且堆也无法再扩展时



------

##### 常量池<span id ='constant_pool'></span>

> 分为**静态常量池**（class文件中的常量池）和**运行时常量池**

**静态常量**：

> 这种常量池主要用于存放两大类常量：**字面量**(Literal)和**符号引用量**(Symbolic References)，字面量相当于Java语言层面常量的概念，如文本字符串，声明为final的常量值等，符号引用则属于编译原理方面的概念，包括了如下三种类型的常量：
>
> - 类和接口的全限定名
> - 字段名称和描述符
> - 方法名称和描述符

**运行时常量**：

> 就是我们常说的常量池，是jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在**方法区**中。
>
> 还将静态常量池里的符号引用转变为直接引用（*在静态常量池的符号引用有一部分是会被转变为直接引用的，比如说类的静态方法或私有方法，实例构造方法，父类方法，这是因为这些方法不能被重写其他版本，所以能在加载的时候就可以将符号引用转变为直接引用，而其他的一些方法是在这个方法被第一次调用的时候才会将符号引用转变为直接引用的*）。
>
> 一个重要特征是**具备动态性**，运行期间也可能将新的常量放入池中，利用比较多的例如**String类的intern()**方法（查找在常量池中是否存在一份equal相等的字符串,如果有则返回该字符串的引用,如果没有则添加自己的字符串进入常量池）。







































